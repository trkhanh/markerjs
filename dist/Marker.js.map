{"version":3,"sources":["Marker.js"],"names":["global","DATA_ATTR","NODE_TYPE","ELEMENT_NODE","TEXT_NODE","IGNORE_TAGS","ACTIVE","defaults","obj","source","prop","hasOwnProperty","haveSameColor","a","b","dom","color","el","addClass","className","classList","add","removeClass","remove","replace","RegExp","prepend","nodesToPrepend","i","nodes","Array","prototype","slice","call","length","insertBefore","firstChild","append","nodesToAppend","len","appendChild","insertAfter","refEl","parentNode","nextSibling","removeChild","contains","child","wrap","wrapper","unwrap","childNodes","forEach","node","parents","parent","path","push","normalizeTextNodes","nodeType","nodeValue","style","backgroundColor","fromHTML","html","div","document","createElement","innerHTML","getRange","selection","range","getSelection","rangeCount","getRangeAt","removeAllRanges","getWindow","getDocument","defaultView","ownerDocument","hasClass","sortByDepth","arr","descending","sort","TextMarker","element","options","bindEvents","scope","highlightedClass","contextClass","stateClass","onRemoveHighlight","onBeforeHighlight","onAfterHighlight","addEventListener","markerHandler","bind","destroy","unbindEvents","removeEventListener","toggle","doHighlight","keepRange","createdHighlights","normalizeHighlights","timestamp","collapsed","Date","createWrapper","setAttribute","highlightRange","result","highlight","wrapperClone","nodeParent","refineRangeBoundaries","startContainer","endContainer","ancestor","commonAncestorContainer","goDeeper","endOffset","previousSibling","splitText","item","startOffset","done","highlights","indexOf","tagName","trim","cloneNode","hasChildNodes","normalizedHighlights","flattenNestedHighlights","mergeSiblingHighlights","filter","hl","parentElement","value","idx","self","offsetTop","offsetLeft","again","flattenOnce","isHighlight","replaceChild","shouldMerge","current","prev","next","setColor","getColor","removeHighlights","container","getHighlights","removeHighlight","mergeSiblingTextNodes","textNode","params","nodeList","andSelf","grouped","querySelectorAll","hasAttribute","groupHighlights","serializeHighlights","hlDescriptors","JSON","offset","textContent","hlPath","getElementPath","refElement","unshift","outerHTML","join","stringify","deserializeHighlights","json","parse","e","hlDescriptor","deserializationFn","hlNode","text","split","elIndex","pop","shift","console","warn","find","caseSensitive","wnd","scrollX","scrollY","caseSens","body","createTextRange","textRange","moveToElementText","findText","select","collapse","scrollTo","span","window"],"mappings":"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","file":"Marker.js","sourceRoot":"../src","sourcesContent":["(function (global) {\n  \"use strict\";\n\n  var /**\n     * Attribute added by default to every highlight.\n     * @type {string}\n     */\n    DATA_ATTR = \"data-highlighted\",\n    /**\n     * Attribute used to group highlight wrappers.\n     * @type {string}\n     */\n    TIMESTAMP_ATTR = \"data-timestamp\",\n    NODE_TYPE = {\n      ELEMENT_NODE: 1,\n      TEXT_NODE: 3,\n    },\n    /**\n     * Don't highlight content of these tags.\n     * @type {string[]}\n     */\n    IGNORE_TAGS = [\n      \"SCRIPT\",\n      \"STYLE\",\n      \"SELECT\",\n      \"OPTION\",\n      \"BUTTON\",\n      \"OBJECT\",\n      \"APPLET\",\n      \"VIDEO\",\n      \"AUDIO\",\n      \"CANVAS\",\n      \"EMBED\",\n      \"PARAM\",\n      \"METER\",\n      \"PROGRESS\",\n    ],\n    /**\n     * Attribute used to check state of Marker\n     * @type  {string} active\n     */\n    ACTIVE = \"marker-active\",\n    IN_ACTIVE = \"marker-inactive\";\n\n  /**\n   * Fills undefined values in obj with default properties with the same name from source object.\n   * @param {object} obj - target object\n   * @param {object} source - source object with default values\n   * @returns {object}\n   */\n  function defaults(obj, source) {\n    obj = obj || {};\n\n    for (var prop in source) {\n      if (source.hasOwnProperty(prop) && obj[prop] === void 0) {\n        obj[prop] = source[prop];\n      }\n    }\n\n    return obj;\n  }\n\n  /**\n   * Returns true if elements a i b have the same color.\n   * @param {Node} a\n   * @param {Node} b\n   * @returns {boolean}\n   */\n  function haveSameColor(a, b) {\n    return dom(a).color() === dom(b).color();\n  }\n\n  /**\n   * Utility functions to make DOM manipulation easier.\n   * @param {Node|HTMLElement} [el] - base DOM element to manipulate\n   * @returns {object}\n   */\n\n  var dom = function (el) {\n    return /** @lends dom */ {\n      /**\n       * Add class to element.\n       * @param {string} className\n       */\n      addClass: function (className) {\n        if (el.classList) {\n          el.classList.add(className);\n        } else {\n          el.className += \" \" + className;\n        }\n      },\n      /**\n       * Remove class from element\n       * @param {string} className\n       */\n      removeClass: function (className) {\n        if (el.classList) {\n          el.classList.remove(className);\n        } else {\n          el.className = el.className.replace(\n            new RegExp(\"(^|\\\\b)\" + className + \"(\\\\b|$)\", \"gi\"),\n            \" \"\n          );\n        }\n      },\n\n      /**\n       * Prepends child nodes to base element.\n       * @param {Node[]} nodesToPrepend\n       */\n      prepend: function (nodesToPrepend) {\n        var nodes = Array.prototype.slice.call(nodesToPrepend),\n          i = nodes.length;\n\n        while (i--) {\n          el.insertBefore(nodes[i], el.firstChild);\n        }\n      },\n\n      /**\n       * Appends child nodes to base element.\n       * @param {Node[]} nodeToAppend\n       */\n      append: function (nodesToAppend) {\n        var nodes = Array.prototype.slice.call(nodesToAppend);\n        i = nodes.length;\n\n        for (var i = 0, len = nodes.length; i < len; ++i) {\n          el.appendChild(nodes[i]);\n        }\n      },\n\n      /**\n       * Inserts base elements after refEl\n       * @param {Node} refEl - node after which base element will be inserted\n       * @return {Node} - inserted element\n       */\n      insertAfter: function (refEl) {\n        return refEl.parentNode.insertBefore(el, refEl.nextSibling);\n      },\n\n      /**\n       * Inserts base element before refEl.\n       * @param {Node} refEl - node before which base element will be inserted\n       * @returns {Node} - inserted element\n       */\n      insertBefore: function (refEl) {\n        return refEl.parentNode.insertBefore(el, refEl);\n      },\n\n      /**\n       * Removes base element from DOM.\n       */\n      remove: function () {\n        el.parentNode.removeChild(el);\n        el = null;\n      },\n\n      /**\n       * Returns true if base element contains given child.\n       * @param {Node|HTMLElement} child\n       * @returns {boolean}\n       */\n      contains: function (child) {\n        return el !== child && el.contains(child);\n      },\n\n      /**\n       * Wraps base element in wrapper element.\n       * @param {HTMLElement} wrapper\n       * @returns {HTMLElement} wrapper element\n       */\n      wrap: function (wrapper) {\n        if (el.parentNode) {\n          el.parentNode.insertBefore(wrapper, el);\n        }\n\n        wrapper.appendChild(el);\n        return wrapper;\n      },\n\n      /**\n       * Unwraps base element.\n       * @returns {Node[]} - child nodes of unwrapped element.\n       */\n      unwrap: function () {\n        var nodes = Array.prototype.slice.call(el.childNodes),\n          wrapper;\n\n        nodes.forEach(function (node) {\n          wrapper = node.parentNode;\n          dom(node).insertBefore(node.parentNode);\n          dom(wrapper).remove();\n        });\n\n        return nodes;\n      },\n\n      /**\n       * Returns array of base element parents\n       * @returns {HTMLElement[]}\n       */\n      parents: function () {\n        var parent,\n          path = [];\n\n        while (!!(parent == el.parentNode)) {\n          path.push(parent);\n          el = parent;\n        }\n\n        return path;\n      },\n\n      /**\n       * Normalizes text nodes within base element, ie. merges sibling text nodes and assures that every\n       * element node has only one text node.\n       * It should does the same as standard element.normalize, but IE implements it incorrectly.\n       */\n      normalizeTextNodes: function () {\n        if (!el) {\n          return;\n        }\n\n        if (el.nodeType === NODE_TYPE.TEXT_NODE) {\n          while (\n            el.nextSibling &&\n            el.nextSibling.nodeType === NODE_TYPE.TEXT_NODE\n          ) {\n            el.nodeValue += el.nextSibling.nodeValue;\n            el.parentNode.removeChild(el.nextSibling);\n          }\n        } else {\n          dom(el.firstChild).normalizeTextNodes();\n        }\n\n        dom(el.nextSibling).normalizeTextNodes();\n      },\n\n      /**\n       * Returns element background color.\n       * @returns {CSSStyleDeclaration.backgroundColor}\n       */\n      color: function () {\n        return el.style.backgroundColor;\n      },\n\n      /**\n       * Create dom element from given html string\n       * @param {string} html\n       * @returns {NodeList}\n       */\n      fromHTML: function (html) {\n        var div = document.createElement(\"div\");\n        div.innerHTML = html;\n        return div.childNodes;\n      },\n\n      /**\n       * Returns first range of the window of base element.\n       * @returns {Range}\n       */\n      getRange: function () {\n        var selection = dom(el).getSelection(),\n          range;\n\n        if (selection.rangeCount > 0) {\n          range = selection.getRangeAt(0);\n        }\n\n        return range;\n      },\n\n      /**\n       * Removes all ranges of the window of base element.\n       */\n      removeAllRanges: function () {\n        var selection = dom(el).getSelection();\n        selection.removeAllRanges();\n      },\n\n      /**\n       * Returns selection object of the window of base element.\n       * @returns {Selection}\n       */\n      getSelection: function () {\n        return dom(el).getWindow().getSelection();\n      },\n\n      /**\n       * Returns window of the base element.\n       * @returns {Window}\n       */\n      getWindow: function () {\n        return dom(el).getDocument().defaultView;\n      },\n\n      /**\n       * Returns document of the base element.\n       * @returns {HTMLDocument}\n       */\n      getDocument: function () {\n        // if ownerDocument is null then el is the document itself.\n        return el.ownerDocument || el;\n      },\n\n      /**\n       * Validate has class or not\n       * @param {string} className\n       * @returns {boolean}\n       */\n      hasClass: function (className) {\n        return el.classList.contains(className);\n      },\n    };\n  };\n\n  function bindEvents(el, scope) {\n    el.addEventListener(\"mouseup\", scope.markerHandler.bind(scope));\n    el.addEventListener(\"touchend\", scope.markerHandler.bind(scope));\n  }\n\n  function unbindEvents(el, scope) {\n    el.removeEventListener(\"mouseup\", scope.markerHandler.bind(scope));\n    el.removeEventListener(\"touchend\", scope.markerHandler.bind(scope));\n  }\n\n  /**\n   * Returns array without duplicated values.\n   * @param {Array} arr\n   * @returns {Array}\n   */\n  function unique(arr) {\n    return arr.filter(function (value, idx, self) {\n      return self.indexOf(value) === idx;\n    });\n  }\n  /**\n   * Sorts array of DOM elements by its depth in DOM tree.\n   * @param {HTMLElement[]} arr - array to sort.\n   * @param {boolean} descending - order of sort.\n   */\n  function sortByDepth(arr, descending) {\n    arr.sort(function (a, b) {\n      return (\n        dom(descending ? b : a).parents().length -\n        dom(descending ? a : b).parents().length\n      );\n    });\n  }\n\n  /**\n   * Takes range object as parameter and refines it boundaries\n   * @param range\n   * @returns {object} refined boundaries and initial state of highlighting algorithm\n   */\n  function refineRangeBoundaries(range) {\n    var startContainer = range.startContainer,\n      endContainer = range.endContainer,\n      ancestor = range.commonAncestorContainer,\n      goDeeper = true;\n\n    if (range.endOffset === 0) {\n      while (\n        !endContainer.previousSibling &&\n        endContainer.parentNode !== ancestor\n      ) {\n        endContainer = endContainer.parentNode;\n      }\n      endContainer = endContainer.previousSibling;\n    } else if (endContainer.nodeType === NODE_TYPE.TEXT_NODE) {\n      if (range.endOffset < endContainer.nodeValue.length) {\n        endContainer.splitText(range.endOffset);\n      }\n    } else if (range.endOffset > 0) {\n      endContainer = endContainer.childNodes.item(range.endOffset - 1);\n    }\n\n    if (startContainer.nodeType === NODE_TYPE.TEXT_NODE) {\n      if (range.startOffset === startContainer.nodeValue.length) {\n        goDeeper = false;\n      } else if (range.startOffset > 0) {\n        startContainer = startContainer.splitText(range.startOffset);\n        if (endContainer === startContainer.previousSibling) {\n          endContainer = startContainer;\n        }\n      }\n    } else if (range.startOffset < startContainer.childNodes.length) {\n      startContainer = startContainer.childNodes.item(range.startOffset);\n    } else {\n      startContainer = startContainer.nextSibling;\n    }\n\n    return {\n      startContainer: startContainer,\n      endContainer: endContainer,\n      goDeeper: goDeeper,\n    };\n  }\n\n  function TextMarker(element, options) {\n    if (!element) {\n      throw \"Missing anchor element\";\n    }\n\n    this.el = element;\n    this.options = defaults(options, {\n      color: \"#ffff7b\",\n      highlightedClass: \"highlighted\",\n      contextClass: \"marker-context\",\n      stateClass: \"marker-inactive\",\n      onRemoveHighlight: function () {\n        return true;\n      },\n      onBeforeHighlight: function () {\n        return true;\n      },\n      onAfterHighlight: function () {},\n    });\n\n    dom(this.el).addClass(this.options.contextClass);\n    dom(this.el).addClass(this.options.stateClass);\n    bindEvents(this.el, this);\n  }\n\n  /**\n   * Permanently disables highlighting.\n   * Unbinds events and remove context element class.\n   * @memberof TextMarker\n   */\n  TextMarker.prototype.destroy = function () {\n    unbindEvents(this.el, this);\n    dom(this.el).removeClass(this.options.contextClass);\n  };\n\n  TextMarker.prototype.toggle = function () {\n    if (!dom(this.el).hasClass(ACTIVE)) {\n      dom(this.el).addClass(ACTIVE);\n      dom(this.el).removeClass(IN_ACTIVE);\n    } else {\n      dom(this.el).removeClass(ACTIVE);\n      dom(this.el).addClass(IN_ACTIVE);\n    }\n  };\n\n  TextMarker.prototype.markerHandler = function () {\n    if (dom(this.el).hasClass(ACTIVE)) {\n      this.doHighlight();\n    }\n  };\n\n  TextMarker.prototype.doHighlight = function (keepRange) {\n    var range = dom(this.el).getRange(),\n      wrapper,\n      createdHighlights,\n      normalizeHighlights,\n      timestamp;\n\n    if (!range || range.collapsed) {\n      return;\n    }\n\n    if (this.options.onBeforeHighlight(range) === true) {\n      timestamp = +new Date();\n      wrapper = TextMarker.createWrapper(this.options);\n      wrapper.setAttribute(TIMESTAMP_ATTR, timestamp);\n      //Todo: @khanhtran this is not good solution that leak out the logic for handle logic out this lib\n      wrapper.setAttribute(\"onclick\", \"callback_RemoveHighLight(this)\");\n\n      createdHighlights = this.highlightRange(range, wrapper);\n      normalizeHighlights = this.normalizeHighlights(createdHighlights);\n\n      this.options.onAfterHighlight(range, normalizeHighlights, timestamp);\n    }\n\n    if (!keepRange) {\n      dom(this.el).removeAllRanges();\n    }\n  };\n\n  /**\n   * Highlights range.\n   * Wraps text of given range object in wrapper element.\n   * @param {Range} range\n   * @param {HTMLElement} wrapper\n   * @returns {Array} - array of created highlights.\n   * @memberof TextMarker\n   */\n  TextMarker.prototype.highlightRange = function (range, wrapper) {\n    if (!range || range.collapsed) {\n      return [];\n    }\n\n    var result = refineRangeBoundaries(range),\n      startContainer = result.startContainer,\n      endContainer = result.endContainer,\n      goDeeper = result.goDeeper,\n      done = false,\n      node = startContainer,\n      highlights = [],\n      highlight,\n      wrapperClone,\n      nodeParent;\n\n    do {\n      if (goDeeper && node.nodeType === NODE_TYPE.TEXT_NODE) {\n        if (\n          IGNORE_TAGS.indexOf(node.parentNode.tagName) === -1 &&\n          node.nodeValue.trim() !== \"\"\n        ) {\n          wrapperClone = wrapper.cloneNode(true);\n          wrapperClone.setAttribute(DATA_ATTR, true);\n          nodeParent = node.parentNode;\n\n          // highlight if a node is inside the el\n          if (dom(this.el).contains(nodeParent) || nodeParent === this.el) {\n            highlight = dom(node).wrap(wrapperClone);\n            highlights.push(highlight);\n          }\n        }\n\n        goDeeper = false;\n      }\n\n      if (\n        node === endContainer &&\n        !(endContainer.hasChildNodes() && goDeeper)\n      ) {\n        done = true;\n      }\n\n      if (node.tagName && IGNORE_TAGS.indexOf(node.tagName) > -1) {\n        if (endContainer.parentNode === node) {\n          done = true;\n        }\n        goDeeper = false;\n      }\n\n      if (goDeeper && node.hasChildNodes()) {\n        node = node.firstChild;\n      } else if (node.nextSibling) {\n        node = node.nextSibling;\n        goDeeper = true;\n      } else {\n        node = node.parentNode;\n        goDeeper = false;\n      }\n    } while (!done);\n\n    return highlights;\n  };\n\n  TextMarker.prototype.normalizeHighlights = function (highlights) {\n    var normalizedHighlights;\n\n    this.flattenNestedHighlights(highlights);\n    this.mergeSiblingHighlights(highlights);\n\n    // omit removed nodes\n    normalizedHighlights = highlights.filter(function (hl) {\n      return hl.parentElement ? hl : null;\n    });\n\n    normalizedHighlights = unique(normalizedHighlights);\n    normalizedHighlights.sort(function (a, b) {\n      return a.offsetTop - b.offsetTop || a.offsetLeft - b.offsetLeft;\n    });\n\n    return normalizedHighlights;\n  };\n  TextMarker.prototype.flattenNestedHighlights = function (highlights) {\n    var again,\n      self = this;\n\n    sortByDepth(highlights, true);\n\n    function flattenOnce() {\n      var again = false;\n\n      highlights.forEach(function (hl, i) {\n        var parent = hl.parentElement,\n          parentPrev = parent.previousSibling,\n          parentNext = parent.nextSibling;\n\n        if (self.isHighlight(parent)) {\n          if (haveSameColor(parent, hl)) {\n            // if (!hl.nextSibling) {\n            //   dom(hl).insertBefore(parentNext || parent);\n            //   again = true;\n            // }\n\n            // if (!hl.previousSibling) {\n            //   dom(hl).insertAfter(parentPrev || parent);\n            //   again = true;\n            // }\n\n            if (!parent.hasChildNodes()) {\n              dom(parent).remove();\n            } else {\n              parent.replaceChild(hl.firstChild, hl);\n              highlights[i] = parent;\n              again = true;\n            }\n          }\n        }\n      });\n\n      return again;\n    }\n\n    do {\n      again = flattenOnce();\n    } while (again);\n  };\n\n  TextMarker.prototype.mergeSiblingHighlights = function (highlights) {\n    var self = this;\n\n    function shouldMerge(current, node) {\n      return (\n        node &&\n        node.nodeType === NODE_TYPE.ELEMENT_NODE &&\n        haveSameColor(current, node) &&\n        self.isHighlight(node)\n      );\n    }\n\n    highlights.forEach(function (highlight) {\n      var prev = highlight.previousSibling,\n        next = highlight.nextSibling;\n\n      if (shouldMerge(highlight, prev)) {\n        dom(highlight).prepend(prev.childNodes);\n        dom(prev).remove();\n      }\n      if (shouldMerge(highlight, next)) {\n        dom(highlight).append(next.childNodes);\n        dom(next).remove();\n      }\n\n      dom(highlight).normalizeTextNodes();\n    });\n  };\n\n  /**\n   * Sets highlighting color.\n   * @param {string} color - valid CSS color.\n   * @memberof TextMarker\n   */\n  TextMarker.prototype.setColor = function (color) {\n    this.options.color = color;\n  };\n\n  /**\n   * Returns highlighting color.\n   * @returns {string}\n   * @memberof TextMarker\n   */\n  TextMarker.prototype.getColor = function () {\n    return this.options.color;\n  };\n\n  /**\n   * Removes highlights from element. If element is a highlight itself, it is removed as well.\n   * If no element is given, all highlights all removed.\n   * @param {HTMLElement} [element] - element to remove highlights from\n   * @memberof TextMarker\n   */\n  TextMarker.prototype.removeHighlights = function (element) {\n    var container = element || this.el,\n      highlights = this.getHighlights({ container: container }),\n      self = this;\n\n    function mergeSiblingTextNodes(textNode) {\n      var prev = textNode.previousSibling,\n        next = textNode.nextSibling;\n\n      if (prev && prev.nodeType === NODE_TYPE.TEXT_NODE) {\n        textNode.nodeValue = prev.nodeValue + textNode.nodeValue;\n        dom(prev).remove();\n      }\n      if (next && next.nodeType === NODE_TYPE.TEXT_NODE) {\n        textNode.nodeValue = textNode.nodeValue + next.nodeValue;\n        dom(next).remove();\n      }\n    }\n\n    function removeHighlight(highlight) {\n      var textNodes = dom(highlight).unwrap();\n\n      textNodes.forEach(function (node) {\n        mergeSiblingTextNodes(node);\n      });\n    }\n\n    sortByDepth(highlights, true);\n\n    highlights.forEach(function (hl) {\n      if (self.options.onRemoveHighlight(hl) === true) {\n        removeHighlight(hl);\n      }\n    });\n  };\n\n  /**\n   * Returns highlights from given container.\n   * @param params\n   * @param {HTMLElement} [params.container] - return highlights from this element. Default: the element the\n   * Marker is applied to.\n   * @param {boolean} [params.andSelf] - if set to true and container is a highlight itself, add container to\n   * returned results. Default: true.\n   * @param {boolean} [params.grouped] - if set to true, highlights are grouped in logical groups of highlights added\n   * in the same moment. Each group is an object which has got array of highlights, 'toString' method and 'timestamp'\n   * property. Default: false.\n   * @returns {Array} - array of highlights.\n   * @memberof TextMarker\n   */\n  TextMarker.prototype.getHighlights = function (params) {\n    params = defaults(params, {\n      container: this.el,\n      andSelf: true,\n      grouped: false,\n    });\n\n    var nodeList = params.container.querySelectorAll(\"[\" + DATA_ATTR + \"]\"),\n      highlights = Array.prototype.slice.call(nodeList);\n\n    if (params.andSelf === true && params.container.hasAttribute(DATA_ATTR)) {\n      highlights.push(params.container);\n    }\n\n    if (params.grouped) {\n      highlights = groupHighlights(highlights);\n    }\n\n    return highlights;\n  };\n\n  /**\n   * Returns true if element is a highlight.\n   * All highlights have 'data-highlighted' attribute.\n   * @param el - element to check.\n   * @returns {boolean}\n   * @memberof TextMarker\n   */\n  TextMarker.prototype.isHighlight = function (el) {\n    return (\n      el && el.nodeType === NODE_TYPE.ELEMENT_NODE && el.hasAttribute(DATA_ATTR)\n    );\n  };\n\n  /**\n   * Serializes all highlights in the element the Marker is applied to.\n   * @returns {string} - stringified JSON with highlights definition\n   * @memberof TextMarker\n   */\n  TextMarker.prototype.serializeHighlights = function () {\n    var highlights = this.getHighlights(),\n      refEl = this.el,\n      hlDescriptors = [];\n\n    function getElementPath(el, refElement) {\n      var path = [],\n        childNodes;\n\n      do {\n        childNodes = Array.prototype.slice.call(el.parentNode.childNodes);\n        path.unshift(childNodes.indexOf(el));\n        el = el.parentNode;\n      } while (el !== refElement || !el);\n\n      return path;\n    }\n\n    sortByDepth(highlights, false);\n\n    highlights.forEach(function (highlight) {\n      var offset = 0, // Hl offset from previous sibling within parent node.\n        length = highlight.textContent.length,\n        hlPath = getElementPath(highlight, refEl),\n        wrapper = highlight.cloneNode(true);\n\n      wrapper.innerHTML = \"\";\n      wrapper = wrapper.outerHTML;\n\n      if (\n        highlight.previousSibling &&\n        highlight.previousSibling.nodeType === NODE_TYPE.TEXT_NODE\n      ) {\n        offset = highlight.previousSibling.length;\n      }\n\n      hlDescriptors.push([\n        wrapper,\n        highlight.textContent,\n        hlPath.join(\":\"),\n        offset,\n        length,\n      ]);\n    });\n\n    return JSON.stringify(hlDescriptors);\n  };\n\n  /**\n   * Serializes all highlights in the element the Marker is applied to.\n   * @returns {string} - stringified JSON with highlights definition\n   * @memberof TextMarker\n   */\n  TextMarker.prototype.serializeHighlights = function () {\n    var highlights = this.getHighlights(),\n      refEl = this.el,\n      hlDescriptors = [];\n\n    function getElementPath(el, refElement) {\n      var path = [],\n        childNodes;\n\n      do {\n        childNodes = Array.prototype.slice.call(el.parentNode.childNodes);\n        path.unshift(childNodes.indexOf(el));\n        el = el.parentNode;\n      } while (el !== refElement || !el);\n\n      return path;\n    }\n\n    sortByDepth(highlights, false);\n\n    highlights.forEach(function (highlight) {\n      var offset = 0, // Hl offset from previous sibling within parent node.\n        length = highlight.textContent.length,\n        hlPath = getElementPath(highlight, refEl),\n        wrapper = highlight.cloneNode(true);\n\n      wrapper.innerHTML = \"\";\n      wrapper = wrapper.outerHTML;\n\n      if (\n        highlight.previousSibling &&\n        highlight.previousSibling.nodeType === NODE_TYPE.TEXT_NODE\n      ) {\n        offset = highlight.previousSibling.length;\n      }\n\n      hlDescriptors.push([\n        wrapper,\n        highlight.textContent,\n        hlPath.join(\":\"),\n        offset,\n        length,\n      ]);\n    });\n\n    return JSON.stringify(hlDescriptors);\n  };\n\n  /**\n   * Deserializes highlights.\n   * @throws exception when can't parse JSON or JSON has invalid structure.\n   * @param {object} json - JSON object with highlights definition.\n   * @returns {Array} - array of deserialized highlights.\n   * @memberof TextMarker\n   */\n  TextMarker.prototype.deserializeHighlights = function (json) {\n    var hlDescriptors,\n      highlights = [],\n      self = this;\n\n    if (!json) {\n      return highlights;\n    }\n\n    try {\n      hlDescriptors = JSON.parse(json);\n    } catch (e) {\n      throw \"Can't parse JSON: \" + e;\n    }\n\n    function deserializationFn(hlDescriptor) {\n      var hl = {\n          wrapper: hlDescriptor[0],\n          text: hlDescriptor[1],\n          path: hlDescriptor[2].split(\":\"),\n          offset: hlDescriptor[3],\n          length: hlDescriptor[4],\n        },\n        elIndex = hl.path.pop(),\n        node = self.el,\n        hlNode,\n        highlight,\n        idx;\n\n      while (!!(idx = hl.path.shift())) {\n        node = node.childNodes[idx];\n      }\n\n      if (\n        node.childNodes[elIndex - 1] &&\n        node.childNodes[elIndex - 1].nodeType === NODE_TYPE.TEXT_NODE\n      ) {\n        elIndex -= 1;\n      }\n\n      node = node.childNodes[elIndex];\n      hlNode = node.splitText(hl.offset);\n      hlNode.splitText(hl.length);\n\n      if (hlNode.nextSibling && !hlNode.nextSibling.nodeValue) {\n        dom(hlNode.nextSibling).remove();\n      }\n\n      if (hlNode.previousSibling && !hlNode.previousSibling.nodeValue) {\n        dom(hlNode.previousSibling).remove();\n      }\n\n      highlight = dom(hlNode).wrap(dom().fromHTML(hl.wrapper)[0]);\n      highlights.push(highlight);\n    }\n\n    hlDescriptors.forEach(function (hlDescriptor) {\n      try {\n        deserializationFn(hlDescriptor);\n      } catch (e) {\n        if (console && console.warn) {\n          console.warn(\"Can't deserialize highlight descriptor. Cause: \" + e);\n        }\n      }\n    });\n\n    return highlights;\n  };\n\n  /**\n   * Finds and highlights given text.\n   * @param {string} text - text to search for\n   * @param {boolean} [caseSensitive] - if set to true, performs case sensitive search (default: true)\n   * @memberof TextMarker\n   */\n  TextMarker.prototype.find = function (text, caseSensitive) {\n    var wnd = dom(this.el).getWindow(),\n      scrollX = wnd.scrollX,\n      scrollY = wnd.scrollY,\n      caseSens = typeof caseSensitive === \"undefined\" ? true : caseSensitive;\n\n    dom(this.el).removeAllRanges();\n\n    if (wnd.find) {\n      while (wnd.find(text, caseSens)) {\n        this.doHighlight(true);\n      }\n    } else if (wnd.document.body.createTextRange) {\n      var textRange = wnd.document.body.createTextRange();\n      textRange.moveToElementText(this.el);\n      while (textRange.findText(text, 1, caseSens ? 4 : 0)) {\n        if (\n          !dom(this.el).contains(textRange.parentElement()) &&\n          textRange.parentElement() !== this.el\n        ) {\n          break;\n        }\n\n        textRange.select();\n        this.doHighlight(true);\n        textRange.collapse(false);\n      }\n    }\n\n    dom(this.el).removeAllRanges();\n    wnd.scrollTo(scrollX, scrollY);\n  };\n\n  /**\n   * Creates wrapper for highlights.\n   * TextMarker instance calls this method each time it needs to create Marker and pass options retrieved\n   * in constructor.\n   * @param {object} options - the same object as in TextMarker constructor.\n   * @returns {HTMLElement}\n   * @memberof TextMarker\n   * @static\n   */\n  TextMarker.createWrapper = function (options) {\n    var span = document.createElement(\"span\");\n    span.style.backgroundColor = options.color;\n    span.className = options.highlightedClass;\n    return span;\n  };\n\n  global.TextMarker = TextMarker;\n})(window);\n"]}